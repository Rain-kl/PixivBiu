# PixivBiu 二开需求文档（增量）

**新增：SQLite 下载/上传记录 + 可重试堆叠合并（避免重复上传与重复堆叠）**

本文为在既有《需求文档基线》基础上的增量需求，仅描述新增/变更部分。

---

## 1. 背景与目标（增量）

### 1.1 背景问题

在 Immich 存储模式下，存在以下痛点：
1. **重复任务导致重复上传**：同作品/同页反复下载会产生重复资产。
2. **多图作品中途失败导致“散落”**：部分图片上传失败后，作品无法形成堆叠或堆叠重复创建。
3. **堆叠与作者相册的映射缺乏持久化**：无法可靠复用作者相册与作品堆叠的历史结果。

### 1.2 增量目标
1. 本地维护一个 SQLite 数据库，用于持久化记录作品/图片级别的下载上传状态。
2. 通过数据库实现：
   - **上传前判重**：已上传图片直接跳过；
   - **复用堆叠**：若作品已有 Immich stackId，新上传图片直接追加进该堆叠；
   - **任务结束即堆叠**：作品任务完成后（不论是否有失败）都执行堆叠/合并逻辑，避免散落；
   - **重试任务不产生重复堆叠**：重试成功的图片应合并进既有 stackId，而非新建 stack。

---

## 2. 数据库设计（新增）

### 2.1 SQLite 文件与生命周期
- **数据库文件位置**：应用本地数据目录（随应用长期存在）。
- **数据库作用范围**：仅在 `storageMode=IMMICH` 下强依赖；`LOCAL` 模式不写入。
- **清理策略（建议）**：
  - `host/token` 变更：不强制清库，但需区分不同 Immich 实例（见 2.4）。

### 2.2 表 1：作品级记录表（`artwork_upload_record`）

**目的**：记录一个作品（Pixiv artwork）整体进度、堆叠归属、作者相册映射依据。

**字段**：
- `pixivArtworkId`（TEXT / INTEGER，**主键**）
- `authorId`（TEXT / INTEGER）
- `immichStackId`（TEXT，可空；创建/复用堆叠后回填）
- `totalImageCount`（INTEGER，作品总图数）
- `successCount`（INTEGER，成功下载并上传到 Immich 的数量）

**建议补充字段**（实现稳定性必须，但不改变核心字段语义）：
- `createdAt` / `updatedAt`（INTEGER 时间戳）
- `status`（TEXT/INTEGER，可选：`RUNNING`/`FINISHED`；或仅靠 `successCount/total` 判断）

**索引建议**：
- `idx_artwork_authorId`
- `idx_artwork_stackId`
- `idx_artwork_hostKey`

**完成判定规则**（用于“是否下载完成”）：
- `isCompleted = (successCount == totalImageCount)`
- 注意：本增量需求要求“不管有没有失败都允许堆叠”，因此完成判定更多用于展示与统计，不作为堆叠门槛。

### 2.3 表 2：图片级记录表（`artwork_image_record`）

**目的**：记录作品内每张图片（页/文件名）的上传结果，支持上传前判重、失败重试、追加堆叠。

**字段**（核心字段）：
- `pixivArtworkId`（TEXT / INTEGER，**外键关联作品表**）
- `imageName`（TEXT；上传到 Immich 使用的文件名，格式为 `artworkId` + `pageIndex`）
- `downloadSuccess`（INTEGER/BOOLEAN；是否成功下载并完成上传）
- `immichAssetId`（TEXT，可空；上传成功后回填）

**建议补充字段**（推荐）：
- `sourceUrl`（TEXT，可选）

**关键约束**（强烈建议）：
- **唯一键**：`(immichHostKey, pixivArtworkId, pageIndex)` 或 `(immichHostKey, pixivArtworkId, imageName)`
- 若已有 `pageIndex`：优先用 `pageIndex` 唯一；
- 如果暂时不加 `pageIndex`：至少保证 `(pixivArtworkId, imageName)` 唯一，避免重复插入。

**索引建议**：
- `idx_image_artworkId`
- `idx_image_assetId`
- `idx_image_success`

### 2.4 多 Immich 实例隔离（建议）

为防止用户切换 `host/token` 后误判“已上传”，在读写表时，表名后缀带 `<immichHash>`：
- 例如将 `https://immich.example.com/` 归一化为 `https://immich.example.com`，再加上 `token` 做 hash。
- 为了方便表数据查看，将 `tableName_hash` 作为表名，在 Immich 测试连接时创建。

---

## 3. 业务逻辑变更（增量）

### 3.1 上传前检查与跳过（新增）

在下载/上传每张图片前，先查 `artwork_image_record`：

**判定规则**：
1. **存在记录且 `downloadSuccess = true`**：
   - 如果 `immichAssetId` 为空，认为图片已下载但未上传，直接尝试上传；
   - 如果 `immichAssetId` 非空，认为该图片已上传完成 → **直接跳过下载与上传**。
2. **存在记录但 `downloadSuccess = false`**：
   - 认为该图片需要重试 → 执行下载与上传，成功后更新记录。
3. **不存在记录**：
   - 新图片 → 插入初始记录（`downloadSuccess=false`），开始下载上传流程。

**说明**：这里的“下载是否成功”指图片是否下载到本地；“上传成功”代表 `immichAssetId` 有值。

### 3.2 作品级堆叠策略（新增/调整）

为解决“中途失败导致散落”与“重试不产生重复堆叠”，堆叠策略调整为：

**作品任务结束时**（无论是否有失败）都执行堆叠/合并：
- 收集该作品 `artwork_image_record` 中所有 `immichAssetId` 非空的资产列表 `assetIds[]`。
- 若 `assetIds[]` 为空：不堆叠（无可堆叠资产）。
- 若 `immichStackId` 已存在（作品表中非空）：
  - 调用 Immich 的“向既有 stack 追加资产”能力（若 Immich API 仅支持重建 stack，需在技术方案中明确选型与实现）。
  - **目标效果**：重试成功的新图片加入同一个 stack，避免重复堆叠。
- 若 `immichStackId` 不存在：
  - 调用 Immich “Create Stack” 创建堆叠，返回 `stackId` 回写 `artwork_upload_record.immichStackId`。

**“发现新图片且作品已有 stackId，则将这张图片加入堆叠”的实时策略**：
- 当单张图片上传成功后：
  - 若作品表中 `immichStackId` 已存在，可选择“立即追加到 stack”（实时追加），或延迟到作品结束统一追加。
  - **MVP 建议**：作品结束统一追加（减少 API 次数、逻辑更稳）；如需实时体验，可做可选配置。

### 3.3 作品级进度更新（新增）

每张图上传成功后：
- 更新/插入 `artwork_image_record`：`downloadSuccess=true`, `immichAssetId=...`
- 更新 `artwork_upload_record.successCount += 1`
- `totalImageCount` 在作品开始时写入（从 Pixiv 获取页数 N），若再次执行同作品任务，发现 `totalImageCount` 不一致：
  - 以 Pixiv 最新返回为准更新；
  - 并允许新增 `pageIndex` 的记录（如果作品后续新增页的情况存在）。

---

## 4. 流程调整（Immich 模式增量）

### 4.1 单作品处理流程（更新版）

对每个作品（`pixivArtworkId`）：
1. **读取 Pixiv 作品信息**：`authorId`/`authorName`/`title`/`pageCount(N)`/各页 URL
2. **初始化/更新作品记录** `artwork_upload_record`：
   - 若不存在则插入：`totalImageCount=N`, `successCount=0`, `immichStackId=null`
   - 若存在则更新：`totalImageCount=N`（如变化）、`updatedAt`
3. **遍历每一页**（建议以 `pageIndex` 为准）：
   1. 查询 `artwork_image_record` 是否已有该页记录
   2. 若已成功上传 → **跳过**
   3. 否则下载（保存到本地 `./temp/<pixivArtworkId>/` 下）→ 上传 Immich → 写入 `immichAssetId`，标记成功；若整组图片完成（下载完成无错误无缺图），删除对应缓存
4. **作品结束统一堆叠/合并**：
   - 若已有 `immichStackId`：将本次新增成功的 `assetIds` 追加进该 stack（或对齐 Immich API 的合并方式）
   - 若没有 `immichStackId`：用现有成功的 `assetIds` 创建 stack，回填 `stackId`
5. **相册逻辑保持不变**，但可利用作品表中的 `authorId` 映射缓存（与“作者相册对照”一致）

---

## 5. 异常与边界条件（增量）

1. **重复运行同作品任务**：
   - 已成功的图片跳过；失败的图片重试；新出现的图片上传后合并进同一 `stackId`（若已存在）。
2. **作品中途失败（网络/5xx/单页下载失败）**：
   - 作品结束仍执行堆叠：用已成功的 `assetIds` 创建/合并 stack，避免散落。
   - 下次重试成功后：应合并进既有 `stackId`，不新建 stack。
3. **堆叠创建成功但回写 DB 失败**。
4. **切换 Immich host/token**：
   - 若未做 `hostKey` 隔离，可能误判已上传；因此初始化时根据 `hostkey` 初始化表。
5. **图片命名变化导致判重失效**：
   - `imageName` 使用 `artworkId` + `pageIndex` 防止判重导致不一致。

---

## 6. 验收标准（增量）

1. **SQLite 持久化生效**：
   - 每个作品在本地 SQLite 中有作品级记录；每张图有图片级记录。
2. **上传前判重**：
   - 同作品同页已上传成功的图片再次执行任务时会被跳过，不会再次上传生成重复资产。
3. **失败不影响堆叠**：
   - 多图作品执行过程中有失败页，任务结束后仍会对成功资产进行堆叠（创建或合并），时间线不再散落。
4. **重试不产生重复堆叠**：
   - 对同一作品重复执行任务（补齐失败页）时，新增成功的图片会合并进既有 `immichStackId`，不会生成新的 stack。
5. **作品级进度可追踪**：
   - `totalImageCount` 与 `successCount` 能正确反映任务进度与完成状态。